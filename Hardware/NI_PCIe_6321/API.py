"""
Created on Jun 30, 2021

This file is the functions for NI PCIe-6321 DAQ
Works under python3
Requirement: nidaqmx package

@author: Linjie
"""

import collections
import time
import numpy as np
import nidaqmx
import ctypes
import os
import sys


class TriggeredLocationSensor():
    def __init__(self):
        pass

    def init_task(self):
        self.location_sensor = nidaqmx.Task()
        self.location_sensor.ai_channels.add_ai_voltage_chan(physical_channel='Dev1/ai5',
                                                             name_to_assign_to_channel="",
                                                             terminal_config=nidaqmx.constants.TerminalConfiguration.DIFFERENTIAL,
                                                             min_val=-10.0,
                                                             max_val=10.0,
                                                             units=nidaqmx.constants.VoltageUnits.VOLTS,
                                                             custom_scale_name=""
                                                             )

        self.location_sensor.timing.cfg_samp_clk_timing(rate=200,
                                                        source='/Dev1/PFI15',  # need to set the terminal
                                                        active_edge=nidaqmx.constants.Edge.RISING,
                                                        sample_mode=nidaqmx.constants.AcquisitionType.FINITE,
                                                        samps_per_chan=200)
        self.location_sensor.start()

    def get_location_raw_data(self):
        self.location_sensor.wait_until_done()
        location_raw = self.location_sensor.read(number_of_samples_per_channel=200)
        self.location_sensor.close()

        return location_raw

    def get_location_data(self):
        raw_location_data = self.get_location_raw_data()
        location_data = np.asarray(
            raw_location_data) * 10.25065065 + 0.68621441  # Transform voltage data to position data
        location_data = list(location_data)
        return location_data

    def close(self):
        self.location_sensor.close()


class TriggeredCounter():
    """
    This class defined a triggered counter used to get the pulse from APD.
    Use the pulses generated by DAQ to trigger the counter and sync with location sensor
    """

    def __init__(self):
        pass

    def init_task(self):
        self.counter = nidaqmx.Task()
        self.counter.ci_channels.add_ci_count_edges_chan(counter='Dev1/ctr0',
                                                         name_to_assign_to_channel="",
                                                         edge=nidaqmx.constants.Edge.RISING,
                                                         initial_count=0,
                                                         count_direction=nidaqmx.constants.CountDirection.COUNT_UP)
        self.counter.timing.cfg_samp_clk_timing(rate=200,
                                                source='/Dev1/PFI10',
                                                active_edge=nidaqmx.constants.Edge.RISING,
                                                sample_mode=nidaqmx.constants.AcquisitionType.FINITE,
                                                samps_per_chan=200)
        self.counter.start()

    def get_counts_array(self):
        self.counter.wait_until_done()
        cts_arr_raw = self.counter.read(number_of_samples_per_channel=200)
        self.counter.close()

        deq = collections.deque(cts_arr_raw)
        deq.pop()
        deq.appendleft(0)
        cts_arr = np.asarray(cts_arr_raw) - np.asarray(deq)

        return cts_arr.tolist()[1:]
        # The processing will decrease the size by 1)

    def close(self):
        self.counter.close()


class HardwareTimer():
    def __init__(self):
        self.count_freq = 200

    def init_task(self):
        self.counter_out = nidaqmx.Task()
        self.counter_out.co_channels.add_co_pulse_chan_freq(counter='Dev1/ctr1',
                                                            name_to_assign_to_channel="",
                                                            units=nidaqmx.constants.FrequencyUnits.HZ,
                                                            idle_state=nidaqmx.constants.Level.LOW,
                                                            initial_delay=0.0,
                                                            freq=self.count_freq,
                                                            duty_cycle=0.5
                                                            )
        self.counter_out.timing.cfg_implicit_timing(sample_mode=nidaqmx.constants.AcquisitionType.FINITE,
                                                    samps_per_chan=200)

    def change_freq(self, new_freq):
        self.count_freq = new_freq
        self.counter_out.close()
        self.init_task()

    def start_timer(self):
        self.counter_out.start()

    def recycle_timer(self):
        self.counter_out.wait_until_done()
        self.counter_out.close()

    def close(self):
        self.counter_out.close()


class OneTimeCounter_HardwareTimer():
    """
    This class define a counter that counts incoming pulse at a fixe count frequency
    When finished, call self.close() to clean up.
    """

    def __init__(self):
        self.count_freq = 1

    def init_task(self):
        # Output as timer
        self.counter_out = nidaqmx.Task()
        self.counter_out.co_channels.add_co_pulse_chan_freq(counter='Dev1/ctr1',
                                                            name_to_assign_to_channel="",
                                                            units=nidaqmx.constants.FrequencyUnits.HZ,
                                                            idle_state=nidaqmx.constants.Level.LOW,
                                                            initial_delay=0.0,
                                                            freq=self.count_freq,
                                                            duty_cycle=0.5
                                                            )
        self.counter_out.timing.cfg_implicit_timing(sample_mode=nidaqmx.constants.AcquisitionType.FINITE,
                                                    samps_per_chan=2)
        # Input as counter
        self.counter_in = nidaqmx.Task()
        self.counter_in.ci_channels.add_ci_count_edges_chan(counter='Dev1/ctr0',
                                                            name_to_assign_to_channel="",
                                                            edge=nidaqmx.constants.Edge.RISING,
                                                            initial_count=0,
                                                            count_direction=nidaqmx.constants.CountDirection.COUNT_UP)
        self.counter_in.timing.cfg_samp_clk_timing(rate=self.count_freq,
                                                   source='/Dev1/PFI10',
                                                   active_edge=nidaqmx.constants.Edge.RISING,
                                                   sample_mode=nidaqmx.constants.AcquisitionType.FINITE,
                                                   samps_per_chan=2)

    def count_once(self):
        freq = self.count_freq
        self.counter_in.start()
        self.counter_out.start()
        self.counter_in.wait_until_done()
        self.counter_out.wait_until_done()
        cts_arr = self.counter_in.read(number_of_samples_per_channel=2, timeout=10.0)
        self.counter_in.stop()
        self.counter_out.stop()
        if cts_arr[0] > cts_arr[1]:
            return (cts_arr[1] + 0xFFFFFFFF + 1 - cts_arr[0]) * freq
        else:
            return (cts_arr[1] - cts_arr[0]) * freq

    def change_freq(self, new_freq):
        self.count_freq = new_freq
        self.counter_out.close()
        self.init_task()

    def close(self):
        self.counter_in.close()
        self.counter_out.close()


class ODMR_counter():
    def __init__(self):
        self.count_freq = 50

    def init_task(self):
        self.counter = nidaqmx.Task()
        self.counter.ci_channels.add_ci_count_edges_chan(counter='Dev1/ctr0',
                                                         name_to_assign_to_channel="",
                                                         edge=nidaqmx.constants.Edge.RISING,
                                                         initial_count=0,
                                                         count_direction=nidaqmx.constants.CountDirection.COUNT_UP)
        self.counter.timing.cfg_samp_clk_timing(rate=5000000,
                                                source='/Dev1/PFI10',
                                                active_edge=nidaqmx.constants.Edge.RISING,
                                                sample_mode=nidaqmx.constants.AcquisitionType.FINITE,
                                                samps_per_chan=2)

        self.counter.start()

        self.trigger = nidaqmx.Task()
        self.trigger.co_channels.add_co_pulse_chan_freq(counter='Dev1/ctr1',
                                                        name_to_assign_to_channel="",
                                                        units=nidaqmx.constants.FrequencyUnits.HZ,
                                                        idle_state=nidaqmx.constants.Level.LOW,
                                                        initial_delay=0.0,
                                                        freq=self.count_freq,
                                                        duty_cycle=0.5
                                                        )
        self.trigger.timing.cfg_implicit_timing(sample_mode=nidaqmx.constants.AcquisitionType.FINITE,
                                                samps_per_chan=3)

    def counter_start(self):
        self.trigger.start()

    def get_counts(self):
        self.trigger.wait_until_done()
        self.counter.wait_until_done()
        cts_raw = self.counter.read(number_of_samples_per_channel=2)
        cts = cts_raw[1] - cts_raw[0]

        self.counter.close()
        self.trigger.close()

        return cts

    def task_close(self):
        self.trigger.close()
        self.counter.close()


class GatedCounter():
    """
    Gated Counter for Reference Counter and Signal Counter.
    Reference Counter: Counter 0
        Source terminal: PFI 8
        Sample Clock terminal: PFI 10
        Gate terminal: PFI 9
    Signal Counter: Counter 2
        Source terminal: PFI 0
        Sample Clock terminal: PFI 2
        Gate terminal: PFI 1

    """
    def __init__(self):
        pass

    def init_task(self):
        """
        Init Reference Counter and Signal Counter.
        :return: None
        """
        # Init counter for reference signal
        self.gated_counter_ref = nidaqmx.Task()
        self.gated_counter_ref.ci_channels.add_ci_count_edges_chan(counter='Dev1/ctr0',
                                                                   name_to_assign_to_channel="",
                                                                   edge=nidaqmx.constants.Edge.RISING,
                                                                   initial_count=0,
                                                                   count_direction=nidaqmx.constants.CountDirection.COUNT_UP)
        self.gated_counter_ref.timing.cfg_samp_clk_timing(rate=5000000,
                                                          source='/Dev1/PFI10',
                                                          active_edge=nidaqmx.constants.Edge.RISING,
                                                          sample_mode=nidaqmx.constants.AcquisitionType.FINITE,
                                                          samps_per_chan=2)
        # Activate and Assign Gate
        self.gated_counter_ref.triggers.pause_trigger.trig_type = nidaqmx.constants.TriggerType.DIGITAL_LEVEL
        self.gated_counter_ref.triggers.pause_trigger.dig_lvl_src = '/Dev1/PFI9'
        self.gated_counter_ref.triggers.pause_trigger.dig_lvl_when = nidaqmx.constants.Level.LOW

        # Init counter for counter signal
        self.gated_counter_sig = nidaqmx.Task()
        self.gated_counter_sig.ci_channels.add_ci_count_edges_chan(counter='Dev1/ctr2',
                                                                   name_to_assign_to_channel="",
                                                                   edge=nidaqmx.constants.Edge.RISING,
                                                                   initial_count=0,
                                                                   count_direction=nidaqmx.constants.CountDirection.COUNT_UP)
        self.gated_counter_sig.timing.cfg_samp_clk_timing(rate=5000000,
                                                          source='/Dev1/PFI2',
                                                          active_edge=nidaqmx.constants.Edge.RISING,
                                                          sample_mode=nidaqmx.constants.AcquisitionType.FINITE,
                                                          samps_per_chan=2)
        # Activate and Assign Gate
        self.gated_counter_sig.triggers.pause_trigger.trig_type = nidaqmx.constants.TriggerType.DIGITAL_LEVEL
        self.gated_counter_sig.triggers.pause_trigger.dig_lvl_src = '/Dev1/PFI1'
        self.gated_counter_sig.triggers.pause_trigger.dig_lvl_when = nidaqmx.constants.Level.LOW

    def start_task(self):
        """
        Start the Task of Reference Counter and Signal Counter.
        :return: None
        """
        self.gated_counter_ref.start()
        self.gated_counter_sig.start()

    def get_counts(self):
        """
        Get the counts data from Reference Counter and Signal Counter, and close the counter.
        :return: ref_counts, sig_counts
        """
        self.gated_counter_sig.wait_until_done()
        self.gated_counter_ref.wait_until_done()
        sig = self.gated_counter_sig.read(number_of_samples_per_channel=2)
        ref = self.gated_counter_ref.read(number_of_samples_per_channel=2)
        print(ref, sig)
        self.gated_counter_ref.close()
        self.gated_counter_sig.close()
        return ref[0], sig[0]

    def close_task(self):
        """
        Close Reference Counter and Signal Counter.
        :return: None
        """
        self.gated_counter_ref.close()
        self.gated_counter_sig.close()


class SampleTriggerOutput():
    """
    Counter for output the Sample Trigger when receive specific number of pulses.
    Counter Output: Counter 1
        Source terminal: PFI 4
        Output terminal: PFI 13
    """
    def __init__(self):
        # The number of output delay (How many sequence you want)
        self.average = 50000

    def init_task(self):
        """
        Init the counter output and set parameters.
        :return: None
        """
        self.sample_trigger_output = nidaqmx.Task()
        self.sample_trigger_output.co_channels.add_co_pulse_chan_ticks(counter='Dev1/ctr1',
                                                                       source_terminal='/Dev1/PFI4',
                                                                       name_to_assign_to_channel="",
                                                                       idle_state=nidaqmx.constants.Level.LOW,
                                                                       initial_delay=self.average,
                                                                       low_ticks=100,
                                                                       high_ticks=100,
                                                                       )
        self.sample_trigger_output.timing.cfg_implicit_timing(sample_mode=nidaqmx.constants.AcquisitionType.FINITE,
                                                              samps_per_chan=3)

    def start_task(self):
        """
        Start the Task.
        :return: None
        """
        self.sample_trigger_output.start()

    def recycle_task(self):
        """
        Close the task when the trigger generation is done.
        :return: None
        """
        self.sample_trigger_output.wait_until_done()
        self.sample_trigger_output.close()

    def close(self):
        """
        Close the Task anyway.
        :return: None
        """
        self.sample_trigger_output.close()

    def reset_average_time(self, new_average=50000):
        """
        Change the output delay number
        :param new_average: The number of output delay (How many sequence you want)
        :return: None
        """
        self.average = new_average


if __name__ == '__main__':
    output = SampleTriggerOutput()
    output.init_task()
    output.start_task()
    time.sleep(10)
    output.close()
